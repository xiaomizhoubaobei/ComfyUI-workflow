<!-- TOC -->

- [放大](#放大)
    - [放大潜空间](#放大潜空间)
    - [放大像素](#放大像素)
    - [通过模型放大像素](#通过模型放大像素)
    - [在 SDXL 中放大潜空间](#在-sdxl-中放大潜空间)
    - [通过模型放大潜空间](#通过模型放大潜空间)
    - [使用 Tile ControlNet 放大](#使用-tile-controlnet-放大)
- [实验](#实验)
    - [比较放大模型](#比较放大模型)
    - [去噪对潜空间放大的影响](#去噪对潜空间放大的影响)
    - [去噪对像素放大的影响](#去噪对像素放大的影响)

<!-- /TOC -->

# 放大

本节探索了放大图像并应用 *高分辨率修复* 的各种方法。

在继续之前，重要的是理解两个重要概念：

- 潜空间和像素空间的区别
- 传统放大和基于机器学习的放大器的区别
- 去噪的影响

图像生成实际上发生在所谓的"潜空间"中。潜空间是 GPU（或 CPU）处理所有数据的地方；该信息需要由模型（VAE）解释才能转换为像素。

潜空间解码是一个有损过程，需要计算能力，图像越大，您需要的资源就越多。这就是为什么只要可能，我们就尝试在潜空间内工作，并仅在最后阶段转换为像素。

要放大图像或潜空间，我们可以使用传统算法，如双三次、双线性等，或为此目的训练的机器学习模型。

当然，传统方法更快，但结果通常是模糊的，具体取决于放大倍数。为了恢复细节和清晰度，我们可以在放大的图像上应用**第二遍**。

这包括将图像传递给第二个 KSampler 并使用 `denoise` 参数。

去噪值越低，图像看起来越接近原始图像，但第二遍的影响也越小。如果您不关心最终图像是否与原始图像 1:1，您可以增加去噪值并获得非常清晰的结果，尽管与起始生成略有不同。

如果您想保持接近源图像，则应该使用低去噪值。

在像素空间中放大时，**0.25 到 0.5** 之间的去噪足以获得良好的结果。当然，基于模型的放大器将需要更低的去噪值，因为放大的图像应该已经相当好。

相反，放大的潜空间非常嘈杂，您需要高去噪因子。通常，在第二遍中，您至少需要 **0.55 去噪**。

还有基于模型的潜空间放大器，如 [NNLatentUpscale](https://github.com/Ttl/ComfyUi_NNLatentUpscale) 和 [SD Latent Upscaler](https://github.com/city96/SD-Latent-Upscaler)，它们仍然是实验性的，但值得一试。

**总结：** 一旦图像使用任何方法放大，使用尽可能低的去噪因子，以获得最佳结果。只要可能，基于潜空间的放大是更可取的，因为它消耗的资源更少。

现在到工作流。标题直接链接到 JSON 文件。

## [放大潜空间](./upscale_latent.json)

放大潜空间是最简单和最快的方法。

在这个工作流中，我们将潜空间放大 1.5 倍，并应用 0.7 去噪的第二遍。不幸的是，放大的潜空间非常嘈杂，因此最终图像将与源图像非常不同。好处是我们使用了非常少的资源。

<details>
<summary>放大的图像</summary>
<img src="./images/latent_upscale.jpg" width="100%" alt="latent upscale" />
</details>

## [放大像素](./upscale_pixel.json)

在这种情况下，我们正在放大像素。源图像必须首先从潜空间解码，然后我们应用 2x 放大因子和传统插值。

尽管放大因子高于前一个工作流，但我们能够使用 0.55 去噪，因为像素放大的噪声较小。

<details>
<summary>放大的图像</summary>
<img src="./images/pixel_upscale.jpg" width="100%" alt="pixel upscale" />
</details>

## [通过模型放大像素](./upscale_by_model.json)

这就是事情变得有趣的地方。可以说，通过在像素空间中使用模型放大可以获得最佳结果。以下是工作流的摘录，这就是发生的地方：

<img src="./images/upscale_pixel_by_model.png" width="100%" alt="latent upscale" />

1. 源图像必须首先从潜空间解码。

2. 接下来我们需要加载放大模型。在这个示例中，我们使用 [4x-UltraSharp](https://openmodeldb.info/models/4x-UltraSharp)，但可能有几十甚至数百个可用的。没有好坏模型，每个都有其用途。可以开始的好模型有：RealSR、Remacri、UltraSharp，它们都可以在 [OpenmodelDB](https://openmodeldb.info/) 上找到。在 [实验](#Experiments) 中，我们提供了一个放大器比较工作流。

3. 这是实际放大图像的地方。

4. 大多数放大器训练到固定因子，通常是 4x，但您可以找到 8x、3x、2x 甚至 1x（它们通常是去噪滤波器）。我们使用的模型放大到 4x，所以在这个步骤中，我们将图像缩小 0.5 倍，有效地使图像成为原始源的 2x。

5. 在第二遍之前，我们需要将图像转换回潜空间，因为 SD 只能处理潜空间，这是通过 VAE Encode 节点完成的。该过程可能需要一些时间，如果您没有足够的 VRAM，图像将自动平铺并分块编码。如果发生这种情况，编码将明显变慢。

现在放大已完成，图像准备好进行第二遍。这次我们只使用 0.25 去噪，因为我们正在处理一个已经很好的源。请注意，我们在第二遍中需要非常少的步骤。

## [在 SDXL 中放大潜空间](./upscale_latent_SDXL.json)

到目前为止我们探索的相同概念对 SDXL 有效。然而，在 base+refiner 工作流中，放大可能看起来不直观。

如果您不关心放大的图像完全忠实于原始图像，您可以仅用几步使用 base 模型创建草稿，然后放大潜空间并使用 base 应用第二遍，使用 refiner 应用第三遍。

**注意：** 我们在第二遍中使用高级 KSampler，但我们将 `start_at_step` 设置为 **5** 而不是 0。这相当于在 base KSampler 中设置较低的去噪因子：`start_at_step = 0` 与 `denoise = 1.0` 相同。由于此工作流是潜空间放大，我们需要保持此值相对较低，您可以稍微调整它，但在总共 20 步中，通常只允许 3-5 的范围（这与设置 0.6-0.7 去噪相同）。

## [通过模型放大潜空间](./upscale_latent_with_model.json)

正如我们所了解的，尽可能在潜空间中工作而不从/到像素空间来回转换是可取的。同样，放大潜空间会导致非常嘈杂的结果……除非您使用模型。

使用模型放大潜空间不如放大像素那么清晰，但比使用标准放大算法好得多。

在这个工作流中，我们使用 [NNLatentUpscaler](https://github.com/Ttl/ComfyUi_NNLatentUpscale) 扩展，它与 SD1.x 和 SDXL 潜空间都兼容。

放大的图像有点模糊但不嘈杂，我们可以通过应用相对较低的去噪第二遍来恢复一些细节。

## [使用 Tile ControlNet 放大](./upscale_tile_controlnet.json)

Tile 是一个非常有趣的 [ControlNet](https://github.com/lllyasviel/ControlNet-v1-1-nightly)。请确保 [下载它](https://huggingface.co/lllyasviel/ControlNet-v1-1/blob/main/control_v11f1e_sd15_tile.pth) 并将其放在 `ComfyUI/models/controlnet/` 目录中，我们不需要此工作流的预处理器。

**Tile** 接受图像并使用颜色信息作为参考来生成新图像。如果您放大在第一遍中生成的图像，并使用相同的图像作为 Tile 的参考执行第二遍，结果将非常详细且接近原始图像。

这种技术非常高效和灵活，通常被用作首选放大方法。

<img src="images/tile_upscale.png" width="100%" alt="tile upscale" />

1. Tile 在像素空间中工作，所以我们需要解码潜空间。
2. 图像使用简单的 nearest-exact 插值放大到 2x。我们不需要高分辨率图像，因为我们在第二遍中使用非常高的去噪值。
3. 放大的图像移动到潜空间并馈送到第二个采样器。请注意，并不严格要求使用放大的图像作为第二遍的基础，技术上您可以使用空潜空间，然后使用 1.0 的去噪值。然而，通过一些实验，我发现此工作流中呈现的布局提供了更好的结果。
4. 我们加载 Tile control net
5. 我们使用原始（未放大）图像作为参考应用 control net。我们使用相同的文本提示词作为条件，但它通过 control net 传递。我们使用 1.0 作为强度，因为我们希望最终图像尽可能接近原始图像。

最后，我们运行第二遍。您可以调整 controlnet 强度和去噪级别，以尝试保持更接近（或更远离）源。通过降低去噪值，我们更接近原始图像，但我们失去了第二遍的锐化效果。`0.75` 似乎是一个很好的折衷，但取决于图像。

# 实验

## [比较放大模型](./experiments/compare_upscale_models.json)

非常简单的工作流，用于比较几个放大模型。您可以在 [OpenModelDB](https://openmodeldb.info/) 上找到像素放大模型，如果您不知道从哪里开始，请尝试：**UltraSharp**、**RealSR** 或 **Remacri**。

## [去噪对潜空间放大的影响](./experiments/denoise_impact_on_latent.json)

正如我们在 [介绍](#upscale) 中谈到的，放大潜空间会产生大量噪声，需要通过高 `denoise` 第二遍来补偿。

此工作流显示了 4 个去噪级别对潜空间放大图像的影响。低去噪（`0.25`）不足以生成可接受的结果。您可能会注意到最小值在 `0.55` 左右。

## [去噪对像素放大的影响](./experiments/denoise_impact_on_pixel.json)

这与前一个实验类似，但这次我们使用放大模型在像素空间中放大图像。

这次 `0.25` 去噪足以达到令人满意的结果，但有时更高的值将有助于添加细节和修复小错误。